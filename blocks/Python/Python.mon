/*
 * Copyright (c) 2013-present Cumulocity GmbH, Duesseldorf, Germany and/or its affiliates and/or their licensors.
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Cumulocity GmbH
 */
 
package apamax.analyticsbuilder.samples;

using apama.analyticsbuilder.BlockBase;
using apama.analyticsbuilder.Activation;
using apama.analyticsbuilder.Value;

/**
 * Parameters for Python block.
 */
event Python_$Parameters
{
	import "PythonBlockPlugin" as plugin;
	/**
	  * An arbitrary label for the block instance.
	  */
	optional<string> label;
	/**
	 * Python function.
	 *
	 * The python code must define a function onInput that takes inputs and context as arguments and returns a list of outputs.
	 *
	 * @$semanticType pab_codeEditor_python
	 */
	string pythonFunction;
	/** 
	 * This action is called by the framework to validate the parameters of the block. 
	 */
	action $validate() {
		plugin.validate(pythonFunction);
	}
}

/**
 * State for the Python block.
 */
event Python_$State
{
	chunk python_state;
}

/**
 * Python
 *
 * Executes python code on the inputs and produces an output.
 *
 * Python code must define a function onInput that takes inputs and context as an argument and returns a list of outputs.
 * The inputs are a list of five Value objects, with members value, properties and timestamp corresponding to the block inputs.
 * The context contains the following members/functions:
 * - logger - A logger object that can be used to log messages.
 * - getState(key, default) - A function that can be used to get state between activations of the block.
 * - setState(key, value) - A function that can be used to set state between activations of the block.
 * The return value of the function is a list of up to five values corresponding to the block outputs. These can either be bare values, or Value objects, with members value, properties and timestamp. If the function does not generate a value, return None instead.
 * For example:
 * <pre>
import math
def onInput(inputs, context):
	context.setState("counter", context.getState("counter", 0.) + 1.)
	(a, b) = (inputs[0].value, inputs[1].value)
	if a and b:
		return [
			math.fabs(a - b),
			a - b,
			context.getState("counter"),
			Value(True, {'value1': inputs[0].properties['value1'], 'value2': inputs[1].properties['value2']}),
		]
	else:
		return None
 * </pre>
 *
 * @$blockCategory Calculations
 * @$derivedName $label
 */
event Python 
{
	import "PythonBlockPlugin" as plugin;
	
	/**BlockBase object.
	 *
	 * This is initialized by the framework when the block is required for a model.
	 */
	BlockBase $base;
	
	/** Block parameters, filled in by the framework. */
	Python_$Parameters $parameters;

	/** Setup the return vector */
	action $init()
	{
		setOutput := [$setOutput_result1, $setOutput_result2, $setOutput_result3, $setOutput_result4, $setOutput_result5];
		compiled_function := plugin.validate($parameters.pythonFunction);
	}

	/**
	 * This action receives the input values and contains the logic of the block. 
	 *
	 * @param $activation The current activation, contextual information required when generating a block output. Blocks should only use the
	 * <tt>Activation</tt> object passed to them from the framework, never creating their own or holding on to an <tt>Activation</tt> object.
	 * @param $input_value1 First input to the block.
	 * @param $input_value2 Second input to the block.
	 * @param $input_value3 Third input to the block.
	 * @param $input_value4 Fourth input to the block.
	 * @param $input_value5 Fifth input to the block.
	 *
	 * @$inputName value1 inputs[0]
	 * @$inputName value2 inputs[1]
	 * @$inputName value3 inputs[2]
	 * @$inputName value4 inputs[3]
	 * @$inputName value5 inputs[4]
	 */
	action $process(Activation $activation, Value $input_value1, Value $input_value2, Value $input_value3, Value $input_value4, Value $input_value5, Python_$State $blockState)
	{
		if $blockState.python_state.empty() {
			// If the python state is not initialized, we initialize it.
			$blockState.python_state := plugin.createPythonState();
		}
		sequence<Value> results := plugin.execute(compiled_function, $blockState.python_state, [$input_value1, $input_value2, $input_value3, $input_value4, $input_value5]);

		if results.size()>0 {
			integer i := 0;
			while i < results.size() and i < setOutput.size() {
				setOutput[i]($activation, results[i]);
				i := i + 1;
			}
		}
	}
	
	/**
	 * outputs[0]
	 */
	action<Activation,Value> $setOutput_result1;		// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[1]
	 */
	action<Activation,Value> $setOutput_result2;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[2]
	 */
	action<Activation,Value> $setOutput_result3;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[3]
	 */
	action<Activation,Value> $setOutput_result4;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[4]
	 */
	action<Activation,Value> $setOutput_result5;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.

	sequence<action<Activation,Value>> setOutput;
	chunk compiled_function;
}
