/*
 * Copyright (c) 2013-present Cumulocity GmbH, Duesseldorf, Germany and/or its affiliates and/or their licensors.
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Cumulocity GmbH
 */
 
package apamax.analyticsbuilder.samples;

using apama.analyticsbuilder.BlockBase;
using apama.analyticsbuilder.Activation;
using apama.analyticsbuilder.Value;
using com.apama.functional.Fn;

/**
 * Parameters for Python block.
 */
event SmartFunction_$Parameters
{
	import "JSPlugin" as plugin;
	/**
	  * Label.
	  *
	  * An arbitrary label for the block instance.
	  */
	optional<string> label;
	/**
	 * Python function.
	 *
	 * The python code must define a function onInput that takes inputs and context as arguments and returns a list of outputs.
	 *
	 * @$semanticType pab_codeEditor_javascript
	 */
	string smartFunction;
	/** 
	 * This action is called by the framework to validate the parameters of the block. 
	 */
	action $validate() {
		chunk code := plugin.compileJS(smartFunction, 100000, 1000);
	}
}

/**
 * State for the Python block.
 */
event SmartFunction_$State
{
	chunk js_state;
}

/**
 * Smart Function
 *
 * Executes a JS Smart Function on the inputs and produces an output.
 *
 * The Smart Function must export a function onInput that takes inputs and context as arguments and returns a list of outputs.
 *
 * The inputs are a list of five Value objects, with members value, properties and timestamp corresponding to the block inputs.
 *
 * Context has the following methods:
 * <ul>
 *  <li>getState(key, def = null): retrieves a value previously stored in the context under the given key. If no value is found, returns def.</li>
 *  <li>setState(key, value): stores the given value in the context under the given key.</li>
 * </ul>
 *
 * In addition, the console object has log, warn, error and debug members that can be used to log messages to the Analytics Builder log.
 *
 * The return value of the function is a list of up to five values corresponding to the block outputs. These can either be bare values, or Value objects, with members value, properties and timestamp. If the function does not generate a value, return null instead.
 *
 * For example:
<pre>
export function onInput(inputs, context) {<br/>
&nbsp;&nbsp;console.log("Processing inputs");<br/>
&nbsp;&nbsp;context.setState("count", context.getState("count", 0) + 1);<br/>
&nbsp;&nbsp;if (inputs[0].value != null && inputs[1].value != null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs[0].value - inputs[1].value,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value: inputs[0].value - inputs[1].value,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properties: { ...inputs[0].properties, ...inputs[1].properties }}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return null;<br/>
}<br/>
</pre>
 *
 * @$blockCategory Calculations
 * @$derivedName $label
 */
event SmartFunction
{
	import "JSPlugin" as plugin;
	
	/**BlockBase object.
	 *
	 * This is initialized by the framework when the block is required for a model.
	 */
	BlockBase $base;
	
	/** Block parameters, filled in by the framework. */
	SmartFunction_$Parameters $parameters;

	/** Setup the return vector */
	action $init()
	{
		setOutput := [$setOutput_result1, $setOutput_result2, $setOutput_result3, $setOutput_result4, $setOutput_result5];
		compiled_function := plugin.compileJS($parameters.smartFunction, 100000, 1000);
	}

	/**
	 * This action receives the input values and contains the logic of the block. 
	 *
	 * @param $activation The current activation, contextual information required when generating a block output. Blocks should only use the
	 * <tt>Activation</tt> object passed to them from the framework, never creating their own or holding on to an <tt>Activation</tt> object.
	 * @param $input_value1 First input to the block.
	 * @param $input_value2 Second input to the block.
	 * @param $input_value3 Third input to the block.
	 * @param $input_value4 Fourth input to the block.
	 * @param $input_value5 Fifth input to the block.
	 *
	 * @$inputName value1 inputs[0]
	 * @$inputName value2 inputs[1]
	 * @$inputName value3 inputs[2]
	 * @$inputName value4 inputs[3]
	 * @$inputName value5 inputs[4]
	 */
	action $process(Activation $activation, Value $input_value1, Value $input_value2, Value $input_value3, Value $input_value4, Value $input_value5, SmartFunction_$State $blockState)
	{
		if $blockState.js_state.empty() {
			chunk initCode := plugin.compileJS("export function makeState() {\n"+
					"  const store = Object.create(null);\n"+
					"  return {\n"+
					"    getState(key, def = null) {\n"+
					"      return key in store ? store[key] : def;\n"+
					"    },\n"+
					"    setState(key, value) {\n"+
					"      store[key] = value;\n"+
					"    },\n"+
					"  };\n"+
					"}\n", 100000, 1000);
			$blockState.js_state := plugin.createJSObject(initCode, "makeState", new sequence<any>);
			plugin.destroyJS(initCode);
		}
		any r := plugin.executeJS(compiled_function, "onInput", [[$input_value1, $input_value2, $input_value3, $input_value4, $input_value5], $blockState.js_state]);

		if not r.empty() {
			sequence<any> results := <sequence<any>> r;
			if results.size()>0 {
				integer i := 0;
				while i < results.size() and i < setOutput.size() {
					any rv := results[i];
					Value v := new Value;
					if not rv.empty() {
						switch (rv) {
							case float: { v.value := rv; }
							case integer: { v.value := rv.toFloat(); }
							case string: { v.value := rv; }
							case boolean: { v.value := rv; }
							default: {
								if results[i].hasEntry("value") {
									switch (results[i].getEntry("value") as rval) {
										case float: { v.value := rval; }
										case integer: { v.value := rval.toFloat(); }
										case string: { v.value := rval; }
										case boolean: { v.value := rval;	}
									}
								}
								if results[i].hasEntry("properties") {
									log results[i].getEntry("properties").valueToString();
									v.properties := <dictionary<string,any>> Fn.mapKeys(results[i].getEntry("properties"), Fn.toType("string"));
								}
								if results[i].hasEntry("timestamp") {
									v.timestamp := <float> results[i].getEntry("timestamp");
								}
							}
						}
						setOutput[i]($activation, v);
					}
					i := i + 1;
				}
			}
		}
	}
	
	/**
	 * outputs[0]
	 *
	 * This is the first output of the block.
	 */
	action<Activation,Value> $setOutput_result1;		// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[1]
	 *
	 * This is the second output of the block.
	 */
	action<Activation,Value> $setOutput_result2;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[2]
	 *
	 * This is the third output of the block.
	 */
	action<Activation,Value> $setOutput_result3;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[3]
	 *
	 * This is the fourth output of the block.
	 */
	action<Activation,Value> $setOutput_result4;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[4]
	 *
	 * This is the fifth output of the block.
	 */
	action<Activation,Value> $setOutput_result5;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.

	sequence<action<Activation,Value>> setOutput;
	chunk compiled_function;
}
