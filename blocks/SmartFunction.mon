/*
 * Copyright (c) 2013-present Cumulocity GmbH, Duesseldorf, Germany and/or its affiliates and/or their licensors.
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Cumulocity GmbH
 */
 
package apamax.analyticsbuilder.samples;

using apama.analyticsbuilder.BlockBase;
using apama.analyticsbuilder.Activation;
using apama.analyticsbuilder.Value;

/**
 * Parameters for Python block.
 */
event SmartFunction_$Parameters
{
	import "JSPlugin" as plugin;
	/**
	  * Label.
	  *
	  * An arbitrary label for the block instance.
	  */
	optional<string> label;
	/**
	 * Python function.
	 *
	 * The python code must define a function onInput that takes inputs and context as arguments and returns a list of outputs.
	 *
	 * @$semanticType pab_codeEditor_javascript
	 */
	string smartFunction;
	/** 
	 * This action is called by the framework to validate the parameters of the block. 
	 */
	action $validate() {
		chunk code := plugin.compileJS(smartFunction, 100000, 1000);
		plugin.destroyJS(code);
	}
}

/**
 * State for the Python block.
 */
event SmartFunction_$State
{
	chunk js_state;
}

/**
 * Smart Function
 *
 * Executes a JS Smart Function on the inputs and produces an output.
 *
 * The Smart Function must export a function onInput that takes inputs and context as an argument and returns a list of outputs.
 *
 * The inputs are a list of five Value objects, with members value, properties and timestamp corresponding to the block inputs.
 *
 * The context contains the following members/functions:
 <ul>
 <li>logger - A logger object that can be used to log messages.</li>
 <li>getState(key, default) - A function that can be used to get state between activations of the block.</li>
 <li>setState(key, value) - A function that can be used to set state between activations of the block.</li>
 </ul>

 The return value of the function is a list of up to five values corresponding to the block outputs. These can either be bare values, or Value objects, with members value, properties and timestamp. If the function does not generate a value, return None instead.
 
 *
 * @$blockCategory Calculations
 * @$derivedName $label
 */
event SmartFunction
{
	import "JSPlugin" as plugin;
	
	/**BlockBase object.
	 *
	 * This is initialized by the framework when the block is required for a model.
	 */
	BlockBase $base;
	
	/** Block parameters, filled in by the framework. */
	SmartFunction_$Parameters $parameters;

	/** Setup the return vector */
	action $init()
	{
		setOutput := [$setOutput_result1, $setOutput_result2, $setOutput_result3, $setOutput_result4, $setOutput_result5];
		compiled_function := plugin.compileJS($parameters.smartFunction, 100000, 1000);
	}

	/**
	 * This action receives the input values and contains the logic of the block. 
	 *
	 * @param $activation The current activation, contextual information required when generating a block output. Blocks should only use the
	 * <tt>Activation</tt> object passed to them from the framework, never creating their own or holding on to an <tt>Activation</tt> object.
	 * @param $input_value1 First input to the block.
	 * @param $input_value2 Second input to the block.
	 * @param $input_value3 Third input to the block.
	 * @param $input_value4 Fourth input to the block.
	 * @param $input_value5 Fifth input to the block.
	 *
	 * @$inputName value1 inputs[0]
	 * @$inputName value2 inputs[1]
	 * @$inputName value3 inputs[2]
	 * @$inputName value4 inputs[3]
	 * @$inputName value5 inputs[4]
	 */
	action $process(Activation $activation, Value $input_value1, Value $input_value2, Value $input_value3, Value $input_value4, Value $input_value5, SmartFunction_$State $blockState)
	{
		any r := plugin.executeJS(compiled_function, "onInput", [<any>[$input_value1, $input_value2, $input_value3, $input_value4, $input_value5]]);

		if not r.empty() {
			sequence<any> results := <sequence<any>> r;
			if results.size()>0 {
				integer i := 0;
				while i < results.size() and i < setOutput.size() {
					any rv := results[i];
					Value v := new Value;
					if not rv.empty() {
						switch (rv) {
							case float: { v.value := rv; }
							case integer: { v.value := rv; }
							case string: { v.value := rv; }
							case boolean: { v.value := rv; }
							default: {
								v.value := (<dictionary<any, any>>results[i]).getOr("value", true);
								v.properties := <dictionary<string,any>> (<dictionary<any, any>>results[i]).getOr("properties", new dictionary<string, any>);
								v.timestamp := <float> (<dictionary<any, any>>results[i]).getOr("timestamp", 0.0);
							}
						}
						setOutput[i]($activation, v);
					}
					i := i + 1;
				}
			}
		}
	}
	
	/**
	 * outputs[0]
	 *
	 * This is the first output of the block.
	 */
	action<Activation,Value> $setOutput_result1;		// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[1]
	 *
	 * This is the second output of the block.
	 */
	action<Activation,Value> $setOutput_result2;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[2]
	 *
	 * This is the third output of the block.
	 */
	action<Activation,Value> $setOutput_result3;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[3]
	 *
	 * This is the fourth output of the block.
	 */
	action<Activation,Value> $setOutput_result4;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.
	
	/**
	 * outputs[4]
	 *
	 * This is the fifth output of the block.
	 */
	action<Activation,Value> $setOutput_result5;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.

	sequence<action<Activation,Value>> setOutput;
	chunk compiled_function;
}
